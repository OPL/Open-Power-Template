<?php
/*
 *  OPEN POWER LIBS <http://www.invenzzia.org>
 *
 * This file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE. It is also available through
 * WWW at this URL: <http://www.invenzzia.org/license/new-bsd>
 *
 * Copyright (c) Invenzzia Group <http://www.invenzzia.org>
 * and other contributors. See website for details.
 *
 * $Id$
 */

/**
 * The lexer class for the CDF parser. Note: this file
 * is automatically generated by PHP Parser Generator lexer
 * by Gregory Beaver. Do not modify it manually. Instead,
 * use the file /tools/lexer/cdf_lexer.plex and parse
 * it with /tools/lexer/generateCdf.php.
 */
class Opt_Cdf_Lexer
{
	/**
	 * The data field for the lexical analyzer.
	 */
	private $_data;
	/**
	 * The token counter for the lexical analyzer.
	 */
	private $_counter;
	/**
	 * The line counter for the lexical analyzer.
	 */
	private $_line;

	/**
	 * The recognized token number for parser.
	 * @var integer
	 */
	public $token;

	/**
	 * The recognized token value for parser.
	 * @var string
	 */
	public $value;

	/**
	 * Constructs the lexer object for parsing the specified
	 * expression.
	 *
	 * @param string $expression The expression to parse.
	 */
	public function __construct($filename)
	{
		$this->_data = file_get_contents($filename);
		$this->_line = 1;
		$this->_counter = 0;
	} // end __construct();

/*!lex2php
%input $this->_data
%counter $this->_counter
%token $this->token
%value $this->value
%line $this->_line
linebreak = /\n|\r\n/
whitespace	= /\s+/
singleline_comment	= /\/\//
multiline_comment_start	= #\/\*#
multiline_comment_end = #\*\/#
id = #[a-zA-Z\_][a-zA-Z0-9]*#
lcurlybracket = /\{/
rcurlybracket = /\}/
dot = /\./
pause = /\-/
slash = /\//
colon = /\:/
semicolon = /\;/
hash = /\#/
comma = /\,/
other_multiline = /.+(?=\*\/)/
other_singleline = /.+(?=\n|\r\n)/
*/

/*!lex2php
%statename INITIAL

multiline_comment_start{
	$this->yypushstate(self::MULTILINE_COMMENT);
	$this->token = 'w';
	echo "going in multiline\n";
}
singleline_comment{
	$this->yypushstate(self::SINGLELINE_COMMENT);
	$this->token = 'w';
	echo "going in singleline\n";
}
whitespace {
	$this->token = 'w';
}
linebreak{
	$this->line++;
}
id {
	$this->token = Opt_Cdf_Parser::T_ID;
}
lcurlybracket{
	$this->token = Opt_Cdf_Parser::T_LCURBRACKET;
}
rcurlybracket{
	$this->token = Opt_Cdf_Parser::T_RCURBRACKET;
}
dot{
	$this->token = Opt_Cdf_Parser::T_DOT;
}
pause{
	$this->token = Opt_Cdf_Parser::T_PAUSE;
}
slash{
	$this->token = Opt_Cdf_Parser::T_DOT;
}
colon{
	$this->token = Opt_Cdf_Parser::T_COLON;
}
semicolon{
	$this->token = Opt_Cdf_Parser::T_SEMICOLON;
}
comma{
	$this->token = Opt_Cdf_Parser::T_COMMA;
}
hash{
	$this->token = Opt_Cdf_Parser::T_HASH;
}
other_multiline{
	throw new Exception('AAA!!!');
}
other_singleline{
	throw new Exception('BBB!!!');
}
*/

/*!lex2php
%statename SINGLELINE_COMMENT
linebreak{
	$this->line++;
	$this->yypopstate();
	echo "going out singleline\n";
	$this->token = 'w';
}
other_singleline{
	$this->token = 'w';
}
*/

/*!lex2php
%statename MULTILINE_COMMENT
multiline_comment_end{
	$this->yypopstate();
	$this->token = 'w';
	echo "going out multiline\n";
}
linebreak{
	$this->line++;
	$this->token = 'w';
}
other_multiline{	
	$this->token = 'w';
}
*/
} // end Opt_Cdf_Lexer;