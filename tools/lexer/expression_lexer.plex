<?php
/*
 *  OPEN POWER LIBS <http://www.invenzzia.org>
 *
 * This file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE. It is also available through
 * WWW at this URL: <http://www.invenzzia.org/license/new-bsd>
 *
 * Copyright (c) Invenzzia Group <http://www.invenzzia.org>
 * and other contributors. See website for details.
 *
 * $Id$
 */

/**
 * The lexer class for the expression parser. Note: this file
 * is automatically generated by PHP Parser Generator lexer
 * by Gregory Beaver. Do not modify it manually. Instead,
 * use the file /tools/lexer/expression_lexer.plex and parse
 * it with /tools/lexer/generateExpression.php.
 */
class Opt_Expression_Standard_Lexer
{
	/**
	 * The data field for the lexical analyzer.
	 */
	private $_data;
	/**
	 * The token counter for the lexical analyzer.
	 */
	private $_counter;
	/**
	 * The line counter for the lexical analyzer.
	 */
	private $_line;

	/**
	 * The recognized token number for parser.
	 * @var integer
	 */
	public $token;

	/**
	 * The recognized token value for parser.
	 * @var string
	 */
	public $value;

	/**
	 * Constructs the lexer object for parsing the specified
	 * expression.
	 *
	 * @param string $expression The expression to parse.
	 */
	public function __construct($expression)
	{
		$this->_data = $expression;
		$this->_line = 1;
		$this->_counter = 0;
	} // end __construct();


/*!lex2php
%input $this->_data
%counter $this->_counter
%token $this->token
%value $this->value
%line $this->_line
whitespace	= /\s+/
incdec	= /(\+\+|\-\-)/
add		= /\+|add/
minus	= /\-/
sub		= /sub/
mul		= /\*|mul/
div		= /\/|div/
mod		= /\%|mod/
exp		= /\^|exp/
and		= /and/
or		= /or/
xor		= /xor/
not		= /\!|not/
eq		= /\=\=|eq/
eqt		= /\=\=\=|eqt/
neq		= /\!\=|neq/
neqt	= /\!\=|neqt/
dot		= /\./
lt		= /lt/
lte		= /lte/
gt		= /gt/
gte		= /gte/
concat	= /\~/
is_between		= /is\s+between/
is_not_between	= /is\s+not\s+between/
is_either		= /is\s+either/
is_neither		= /is\s+neither/
contains_both		= /contains\s+both/
contains_either		= /contains\s+either/
contains_neither	= /contains\s+neither/
contains	= /contains/
is_in			= /is\s+in/
is_not_in		= /is\s+not\s+in/
is_both_in		= /is\s+in\s+both/
is_either_in	= /is\s+in\s+either/
is_neither_in	= /is\s+in\s+neither/
nor			= /nor/
lbracket	= /\(/
rbracket	= /\)/
assign		= /\=|is/
exists		= /exists/
clone		= /clone/
new			= /new/
null		= /null/
true		= /true/
false		= /false/
dollar		= /\$/
at			= /\@/
dlsq_bracket	= /\</
drsq_bracket	= /\>/
lsq_bracket	= /\[/
rsq_bracket	= /\]/
object_op	= /\:\:/
comma		= /\,/
colon		= /\:/
identifier	= /[a-zA-Z\_][a-zA-Z0-9\_]*/
string		= /'[^'\\]*(?:\\.[^'\\]*)*'/
backticks	= /`[^`\\]*(?:\\.[^`\\]*)*`/
number		= /[0-9]+\.?[0-9]*/
hexadecimal	= /0[xX][0-9a-fA-F]+/
other		= /./
*/
/*!lex2php
%statename CODE
whitespace {
	$this->token = 'w';
}
incdec {
	if($this->value == '++')
	{
		$this->token = Opt_Expression_Standard_Parser::T_INCREMENT;
	}
	else
	{
		$this->token = Opt_Expression_Standard_Parser::T_DECREMENT;
	}
}
add {
	$this->token = Opt_Expression_Standard_Parser::T_ADD;
}
minus {
	$this->token = Opt_Expression_Standard_Parser::T_MINUS;
}
sub {
	$this->token = Opt_Expression_Standard_Parser::T_SUB;
}
mul {
	$this->token = Opt_Expression_Standard_Parser::T_MUL;
}
div {
	$this->token = Opt_Expression_Standard_Parser::T_DIV;
}
mod {
	$this->token = Opt_Expression_Standard_Parser::T_MOD;
}
exp {
	$this->token = Opt_Expression_Standard_Parser::T_EXP;
}
and {
	$this->token = Opt_Expression_Standard_Parser::T_AND;
}
or {
	$this->token = Opt_Expression_Standard_Parser::T_OR;
}
nor {
	$this->token = Opt_Expression_Standard_Parser::T_NOR;
}
not {
	$this->token = Opt_Expression_Standard_Parser::T_NOT;
}
xor {
	$this->token = Opt_Expression_Standard_Parser::T_XOR;
}
eq {
	$this->token = Opt_Expression_Standard_Parser::T_EQUALS;
}
eqt {
	$this->token = Opt_Expression_Standard_Parser::T_EQUALS_T;
}
neq {
	$this->token = Opt_Expression_Standard_Parser::T_NEQUALS;
}
neqt {
	$this->token = Opt_Expression_Standard_Parser::T_NEQUALS_T;
}
gt {
	$this->token = Opt_Expression_Standard_Parser::T_GT;
}
lt {
	$this->token = Opt_Expression_Standard_Parser::T_LT;
}
gte {
	$this->token = Opt_Expression_Standard_Parser::T_GTE;
}
lte {
	$this->token = Opt_Expression_Standard_Parser::T_LTE;
}
concat {
	$this->token = Opt_Expression_Standard_Parser::T_CONCAT;
}
contains {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS;
}
is_between {
	$this->token = Opt_Expression_Standard_Parser::T_IS_BETWEEN;
}
is_not_between {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NOT_BETWEEN;
}
is_either {
	$this->token = Opt_Expression_Standard_Parser::T_IS_EITHER;
}
is_neither {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NEITHER;
}
contains_both {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_BOTH;
}
contains_either {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_EITHER;
}
contains_neither {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_NEITHER;
}
is_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_IN;
}
is_not_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NOT_IN;
}
is_both_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_BOTH_IN;
}
is_either_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_EITHER_IN;
}
is_neither_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NEITHER_IN;
}
new {
	$this->token = Opt_Expression_Standard_Parser::T_NEW;
}
clone {
	$this->token = Opt_Expression_Standard_Parser::T_CLONE;
}
exists {
	$this->token = Opt_Expression_Standard_Parser::T_EXISTS;
}
null {
	$this->token = Opt_Expression_Standard_Parser::T_NULL;
}
true {
	$this->token = Opt_Expression_Standard_Parser::T_TRUE;
}
false {
	$this->token = Opt_Expression_Standard_Parser::T_FALSE;
}
dollar {
	$this->token = Opt_Expression_Standard_Parser::T_DOLLAR;
}
at {
	$this->token = Opt_Expression_Standard_Parser::T_AT;
}
dot {
	$this->token = Opt_Expression_Standard_Parser::T_DOT;
}
assign {
	$this->token = Opt_Expression_Standard_Parser::T_ASSIGN;
}
lbracket {
	$this->token = Opt_Expression_Standard_Parser::T_L_BRACKET;
}
rbracket {
	$this->token = Opt_Expression_Standard_Parser::T_R_BRACKET;
}
dlsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_DLSQ_BRACKET;
}
drsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_DRSQ_BRACKET;
}
lsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_LSQ_BRACKET;
}
rsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_RSQ_BRACKET;
}
object_op {
	$this->token = Opt_Expression_Standard_Parser::T_OBJECT_OPERATOR;
}
comma {
	$this->token = Opt_Expression_Standard_Parser::T_COMMA;
}
colon {
	$this->token = Opt_Expression_Standard_Parser::T_COLON;
}
add {
	$this->token = Opt_Expression_Standard_Parser::T_ADD;
}
identifier {
	$this->token = Opt_Expression_Standard_Parser::T_IDENTIFIER;
}
string {
	$this->token = Opt_Expression_Standard_Parser::T_STRING;
}
backticks {
	$this->token = Opt_Expression_Standard_Parser::T_BACKTICKS;
}
number {
	$this->token = Opt_Expression_Standard_Parser::T_NUMBER;
}
hexadecimal {
	$this->token = Opt_Expression_Standard_Parser::T_NUMBER;
}
*/

} // end Opt_Expression_Standard_Lexer;