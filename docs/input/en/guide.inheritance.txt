Title: Template inheritance
SeeAlso:
 - syntax.topics.modularization.inheritance
 - syntax.instructions.snippet

----

Template inheritance is another way of modularizing your templates. It offers you another way to compose the output document from several template files and is very similar to the concepts that can be found in the object-oriented programming. In this chapter we are going to describe the implementation of template inheritance in Open Power Template.

Short introduction to snippets
==============================

One of the advantages of the new templating language is the fact that it may allow the manipulations that are impossible in pure PHP. One of such manipulations is described right here. It is the fundamental feature used by the template inheritance, and moreover, it is widely used in many other places. As you should remember, the template processing in OPT consists of two phases:

- The compilation of the template to PHP
- The execution of the compiled PHP code.

The first phase is done only when the template has been modified. Because of the performance reasons, in any other cases, OPT just executes the previously compiled template. So far, we have met the features that are active during the execution: the expressions, sections, etc. - all of them process the data from the script and generate the output HTML code when the template is executed. On the other hand, **snippets** work during the compilation only. They work much like macros - they capture a piece of the template code and allow to paste it in several other places. To see, how they work, consider the following template:

~~~~
[xml]
<?xml version="1.0" ?>
<opt:root>
	<opt:snippet name="foo">
		<p>The value of the variable is {@variable}</p>
	</opt:snippet>
	
	{@variable is 5}
	<opt:insert snippet="foo" />
	
	{@variable is 10}
	<opt:insert snippet="foo" />
</opt:root>
~~~~

The result produced by the template is:

~~~~
<p>The value of the variable is 5</p>
<p>The value of the variable is 10</p>
~~~~

As you can see, the code captured by the snippet still remains dynamic. Inserted in different places, it could produce different results, depending on the actual variable values etc. Furthermore, it is even more smart. In some cases, it is able to self-modify to provide a better integration with a particular place. It is especially visible with the sections:

~~~~
[xml]
<?xml version="1.0" ?>
<opt:root>
	<opt:snippet name="user">
	<div>
		<p>Nick: {$user.nick}</p>
		<p>Age: {$user.age}</p>
	</div>
	</opt:snippet>
	
	<opt:section name="members" opt:use="user" />
	<opt:section name="admins" opt:use="user" />
</opt:root>
~~~~

Let's unroll the actual code to see, what goes to the execution stage:

~~~~
[xml]
<?xml version="1.0" ?>
<opt:root>
	<opt:section name="members">
	<div>
		<p>Nick: {$members.nick}</p>
		<p>Age: {$members.age}</p>
	</div>
	</opt:section>
	<opt:section name="admins">
	<div>
		<p>Nick: {$admins.nick}</p>
		<p>Age: {$admins.age}</p>
	</div>
	</opt:section>
</opt:root>
~~~~

The variable `$user` (the same, as the snippet name) has been automatically replaced with the section names, which simplifies the reuse of the section content. For example, if we have a pagination system built with `opt:selector`, we do not have to copy and paste the pagination layout into every template that uses it. We could simply define a snippet in an extra template, include this template and load the snippet content to the `opt:selector` instruction, like in the example above.

> [warning]
> The snippets require different inclusion techniques than `opt:include`. They will be explained later.

General overview
================

Template inheritance resembles the ordinary inheritance in the object-oriented programming. The classes are represented by the templates, and the methods - by the [snippets][syntax.instructions.snippet]. We may extend one template with another and overwrite the snippets it defines or add some new ones. The only difference is the base template which specifies, where the snippets should be placed and displayed. Below, we can see an image that illustrates the process:

![Template inheritance in OPT](media/inheritance.png "Template inheritance in OPT")

The base template could define the base XHTML code structure, with the `<html>`, `<body>` tags etc. Moreover, it leaves some spare placeholders (with [opt:insert][syntax.instructions.insert]). Then, we extend the template with another one which provides the snippets for the placeholders with the content. As a result, OPT provides the complete output document, where the snippets are inserted into placeholders, overwriting the default content.

A single base template can be extended by many different templates that could contain the code for different website modules: news, articles, etc. Furthermore, if the module A is based on B, it may extend the templates of the module B and overwrite some snippets defined by them. OPT automatically manages the compilation issues.

The template inheritance system in OPT has the following properties:

- Contrary to many other template engines, the inheritance is processed during the compilation time. The inherited template name cannot be read from a variable or any other expression.
- As the snippets are reusable, you may create some generic snippets and use them in various situations.
- Dynamic inheritance is still possible, but in a bit different way.

A sample code
=============

Let's create some sample templates that use the inheritance:

The base template (`base.tpl`):

~~~~
[xml]
<?xml version="1.0" ?>
<opt:root>
<opt:prolog />
<opt:dtd template="xhtml10transitional" />
<html>
<head>
	<title>Hello!</title>
</head>
<body>
	<h1>Title</h1>
	<opt:insert snippet="content">
		<p>Some default content here.</p>
	</opt:snippet>
</body>
</html>
</opt:root>
~~~~

The extending template (`extending.tpl`):

~~~~
[xml]
<?xml version="1.0" ?>
<opt:extend file="base.tpl">
	<opt:snippet name="content">
		<p>Hi universe!</p>
	</opt:snippet>
</opt:extend>
~~~~

The PHP code that runs the templates:

~~~~
[php]
$view = new Opt_View('extending.tpl');

$output = new Opt_Output_Http();
$output->render($view);
~~~~

As we run the code, we should get the following result:

~~~~
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<title>Hello!</title>
</head>
<body>
	<h1>Title</h1>
	<p>Hi universe!</p>
</body>
</html>
~~~~

In the PHP code, we call only the template on the top of the inheritance chain, or in other words - the template that we do not want to extend anymore. From the script-side, we do not have to know about the existence of the base template. The whole inheritance chain is executed in the content of a single view, so all the templates share the same data and see their template variables. The template inheritance increases the performance, compared to the same code achieved with an ordinary `opt:include` instruction. We have less objects and the template engine does not have to perform so many disk operations to detect whether the files need to be recompiled.

Try to modify the base template. Although we do not mention it in the script, OPT knows that it exists and the change is visible automatically, because the library checks also for the modifications the dependant templates.

> [help]
> In both `opt:root` and `opt:extend` you may set the `escaping` attribute which defines the default escaping policy for a single template. The snippets always remember the policy of their "mother" template and restore it even after the insertion.

Dynamic inheritance with branches
=================================

True dynamic inheritance
========================

Template inheritance versus template inclusion
==============================================

Conclusion
==========